# 从内存视角理解 collect

在 Rust 开发中，`collect` 几乎是处理数据的“必经之路”。虽然代码写起来只是简单的一个方法调用，但为了保证性能，标准库在内存底层针对不同的场景设计了非常聪明的处理策略。

本文将通过三个典型的图示，带你透视 `collect` 的真实运作方式：
- **精准分配**：从栈上的 `Range` 开始，它如何通过 `size_hint` 预估空间，实现一次性内存申请？
- **物理复用**：当旧的 `Vec` 被消耗时，它如何直接在原有的堆地址上原地覆盖，达成真正的零成本转换？
- **隔离分配**：在面对借用数据时，它又是如何权衡所有权与性能，安全地开辟新空间？

透过这些内存布局的变化，你将看到 Rust 是如何在保持抽象简洁的同时，把物理性能压榨到极致的。

## 从非堆数据源 (Range) 开始

```rust
let v: Vec<_> = (0..10).map(|x| x + 1).collect();
```

当执行到 `collect()` 时，底层面临的首要挑战是确定堆内存的申请规模。由于 `Range` 结构体只在**栈**上存储 `start` 和 `end`，堆上最初完全没有这组数据。

为了规避频繁扩容带来的拷贝损耗，Rust 采用“先自省、再分配”的策略：
- **逻辑自省**：触发迭代器链的 `size_hint()`，在本例中返回精确值 10。
- **物理落地**：根据预估值一次性申请堆空间，并将数据直接写入。

![从非堆数据源开始](./imgs/collect_from_range.svg)

## 就地重用 (In-place Reuse)

当你将一个 `Vec` 消耗掉（通过 `into_iter`）并转换成另一个 `Vec` 时，如果转换前后的类型（源类型 `T` 和目标类型 `U`）具有**相同的尺寸 (Size) 和对齐量 (Alignment)**，Rust 会开启极致优化。

```rust
let v1: Vec<i32> = (0..10).collect();
let v2: Vec<i32> = v1.into_iter().map(|x| x + 1).collect();
```

在这段代码中，`v2` 会**直接重用** `v1` 曾经占用的堆缓冲区：
1. **所有权接管**：`into_iter()` 将堆指针的所有权转移给迭代器。
2. **零分配覆盖**：`collect` 直接在原地址 (如 `0x500`) 覆盖写入新数据。
3. **特快路径**：利用 `TrustedLen` 标记消除边界检查，实现指令级的直写。

![就地重用](./imgs/collect_inplace_vec.svg)

## 借用与新分配 (Borrow & Allocation)

如果数据源是借用的（通过 `iter`），情况则完全不同。

```rust
let v1: Vec<i32> = (0..10).collect();
let v2: Vec<i32> = v1.iter().map(|x| x + 1).collect();
```

在这种情况下：
1. **物理隔离**：由于 `v1` 仍然持有其堆内存的所有权且可能在后续继续使用，`collect` **必须**开辟一块全新的内存区域。
2. **独立布局**：此时堆上会同时存在两块独立的内存区域：一块是只读的源数据，另一块是新生成的计算结果。

![借用与新分配](./imgs/collect_borrow_vec.svg)

## 总结

`collect` 的高性能源于它对内存物理特性的极致榨取：
- 通过 **`size_hint`** 规避昂贵的重分配。
- 通过 **`TrustedLen`** 赋予编译器更强的优化信息。
- 通过 **`In-place`** 机制实现了内存空间的物理级复用。

这种从高层语法到底层内存布局的完美映射，正是 Rust 性能哲学的核心体现。
